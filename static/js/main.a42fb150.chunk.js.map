{"version":3,"sources":["components/annyang.min.js","components/obs.js","components/login.jsx","components/dashboard.jsx","App.js","serviceWorker.js","index.js"],"names":["__WEBPACK_AMD_DEFINE_RESULT__","root","factory","undefined","annyang","SpeechRecognition","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","recognition","autoRestart","commandsList","callbacks","start","error","end","soundstart","result","resultMatch","resultNoMatch","errorNetwork","errorPermissionBlocked","errorPermissionDenied","lastStartedAt","autoRestartCount","debugState","debugStyle","pauseListening","isListening","optionalParam","optionalRegex","namedParam","splatParam","escapeRegExp","commandToRegExp","command","replace","match","optional","RegExp","invokeCallbacks","_len","arguments","length","args","Array","_key","forEach","callback","apply","context","isInitialized","logMessage","text","extraParameters","indexOf","console","log","initIfNeeded","init","registerCommand","originalPhrase","push","parseResults","results","commandText","i","trim","j","l","currentCommand","exec","parameters","slice","this","commands","resetCommands","abort","maxAlternatives","continuous","location","protocol","lang","onstart","onsoundstart","onerror","event","Date","getTime","onend","timeSinceLastStart","setTimeout","paused","onresult","SpeechRecognitionResult","resultIndex","k","transcript","addCommands","options","e","message","pause","resume","debug","newState","setLanguage","language","cb","phrase","hasOwnProperty","regexp","source","removeCommands","commandsToRemove","isArray","filter","addCallback","type","removeCallback","compareWithCallbackParameter","callbackType","getSpeechRecognizer","trigger","sentences","exports","module","window","OBSwebsocket","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","messageId","address","password","ws","WebSocket","concat","onopen","onOpen","bind","onmessage","onMessage","onError","onclose","onClose","readyState","send","request-type","res","authRequired","authenticate","emit","close","data","JSON","parse","_this2","Promise","resolve","reject","id","generateMessageId","once","status","stringify","String","salt","challenge","passwordSaltHash","shajs","sha256","update","digest","authResponse","auth","EventEmitter","Login","state","host","port","handleChange","setState","defineProperty","target","name","value","handleSubmit","props","client","connect","preventDefault","react_default","a","createElement","authFail","onSubmit","onChange","Component","Dashboard","hello","alert","_ref","asyncToGenerator","regenerator_default","mark","_callee","scene","wrap","_context","prev","next","scene-name","sent","prevState","toConsumableArray","t0","stop","_x","className","map","msg","key","App","Client","connected","on","code","dashboard","login","Boolean","hostname","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a42fb150.chunk.js","sourcesContent":["/* eslint-disable */\n//! annyang\n//! version : 2.6.1\n//! author  : Tal Ater @TalAter\n//! license : MIT\n//! https://www.TalAter.com/annyang/\n(function(root, factory) {\n    \"use strict\";\n    if (typeof define === \"function\" && define.amd) {\n        // AMD + global\n        define([], function() {\n            return (root.annyang = factory(root));\n        });\n    } else if (typeof module === \"object\" && module.exports) {\n        // CommonJS\n        module.exports = factory(root);\n    } else {\n        // Browser globals\n        root.annyang = factory(root);\n    }\n})(typeof window !== \"undefined\" ? window : this, function(root, undefined) {\n    \"use strict\";\n\n    /**\n     * # Quick Tutorial, Intro, and Demos\n     *\n     * The quickest way to get started is to visit the [annyang homepage](https://www.talater.com/annyang/).\n     *\n     * For a more in-depth look at annyang, read on.\n     *\n     * # API Reference\n     */\n\n    var annyang;\n\n    // Get the SpeechRecognition object, while handling browser prefixes\n    var SpeechRecognition =\n        root.SpeechRecognition || root.webkitSpeechRecognition || root.mozSpeechRecognition || root.msSpeechRecognition || root.oSpeechRecognition;\n\n    // Check browser support\n    // This is done as early as possible, to make it as fast as possible for unsupported browsers\n    if (!SpeechRecognition) {\n        return null;\n    }\n\n    var commandsList = [];\n    var recognition;\n    var callbacks = {\n        start: [],\n        error: [],\n        end: [],\n        soundstart: [],\n        result: [],\n        resultMatch: [],\n        resultNoMatch: [],\n        errorNetwork: [],\n        errorPermissionBlocked: [],\n        errorPermissionDenied: []\n    };\n    var autoRestart;\n    var lastStartedAt = 0;\n    var autoRestartCount = 0;\n    var debugState = false;\n    var debugStyle = \"font-weight: bold; color: #00f;\";\n    var pauseListening = false;\n    var isListening = false;\n\n    // The command matching code is a modified version of Backbone.Router by Jeremy Ashkenas, under the MIT license.\n    var optionalParam = /\\s*\\((.*?)\\)\\s*/g;\n    var optionalRegex = /(\\(\\?:[^)]+\\))\\?/g;\n    var namedParam = /(\\(\\?)?:\\w+/g;\n    var splatParam = /\\*\\w+/g;\n    var escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\n    var commandToRegExp = function(command) {\n        command = command\n            .replace(escapeRegExp, \"\\\\$&\")\n            .replace(optionalParam, \"(?:$1)?\")\n            .replace(namedParam, function(match, optional) {\n                return optional ? match : \"([^\\\\s]+)\";\n            })\n            .replace(splatParam, \"(.*?)\")\n            .replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n        return new RegExp(\"^\" + command + \"$\", \"i\");\n    };\n\n    // This method receives an array of callbacks to iterate over, and invokes each of them\n    var invokeCallbacks = function(callbacks, ...args) {\n        callbacks.forEach(function(callback) {\n            callback.callback.apply(callback.context, args);\n        });\n    };\n\n    var isInitialized = function() {\n        return recognition !== undefined;\n    };\n\n    // method for logging in developer console when debug mode is on\n    var logMessage = function(text, extraParameters) {\n        if (text.indexOf(\"%c\") === -1 && !extraParameters) {\n            console.log(text);\n        } else {\n            console.log(text, extraParameters || debugStyle);\n        }\n    };\n\n    var initIfNeeded = function() {\n        if (!isInitialized()) {\n            annyang.init({}, false);\n        }\n    };\n\n    var registerCommand = function(command, callback, originalPhrase) {\n        commandsList.push({ command, callback, originalPhrase });\n        if (debugState) {\n            logMessage(\"Command successfully loaded: %c\" + originalPhrase, debugStyle);\n        }\n    };\n\n    var parseResults = function(results) {\n        invokeCallbacks(callbacks.result, results);\n        var commandText;\n        // go over each of the 5 results and alternative results received (we have set maxAlternatives to 5 above)\n        for (let i = 0; i < results.length; i++) {\n            // the text recognized\n            commandText = results[i].trim();\n            if (debugState) {\n                logMessage(\"Speech recognized: %c\" + commandText, debugStyle);\n            }\n\n            // try and match recognized text to one of the commands on the list\n            for (let j = 0, l = commandsList.length; j < l; j++) {\n                var currentCommand = commandsList[j];\n                var result = currentCommand.command.exec(commandText);\n                if (result) {\n                    var parameters = result.slice(1);\n                    if (debugState) {\n                        logMessage(\"command matched: %c\" + currentCommand.originalPhrase, debugStyle);\n                        if (parameters.length) {\n                            logMessage(\"with parameters\", parameters);\n                        }\n                    }\n                    // execute the matched command\n                    currentCommand.callback.apply(this, parameters);\n                    invokeCallbacks(callbacks.resultMatch, commandText, currentCommand.originalPhrase, results);\n                    return;\n                }\n            }\n        }\n        invokeCallbacks(callbacks.resultNoMatch, results);\n    };\n\n    annyang = {\n        /**\n         * Initialize annyang with a list of commands to recognize.\n         *\n         * #### Examples:\n         * ````javascript\n         * var commands = {'hello :name': helloFunction};\n         * var commands2 = {'hi': helloFunction};\n         *\n         * // initialize annyang, overwriting any previously added commands\n         * annyang.init(commands, true);\n         * // adds an additional command without removing the previous commands\n         * annyang.init(commands2, false);\n         * ````\n         * As of v1.1.0 it is no longer required to call init(). Just start() listening whenever you want, and addCommands() whenever, and as often as you like.\n         *\n         * @param {Object} commands - Commands that annyang should listen to\n         * @param {boolean} [resetCommands=true] - Remove all commands before initializing?\n         * @method init\n         * @deprecated\n         * @see [Commands Object](#commands-object)\n         */\n        init: function(commands, resetCommands = true) {\n            // Abort previous instances of recognition already running\n            if (recognition && recognition.abort) {\n                recognition.abort();\n            }\n\n            // initiate SpeechRecognition\n            recognition = new SpeechRecognition();\n\n            // Set the max number of alternative transcripts to try and match with a command\n            recognition.maxAlternatives = 5;\n\n            // In HTTPS, turn off continuous mode for faster results.\n            // In HTTP,  turn on  continuous mode for much slower results, but no repeating security notices\n            recognition.continuous = root.location.protocol === \"http:\";\n\n            // Sets the language to the default 'en-US'. This can be changed with annyang.setLanguage()\n            recognition.lang = \"en-US\";\n\n            recognition.onstart = function() {\n                isListening = true;\n                invokeCallbacks(callbacks.start);\n            };\n\n            recognition.onsoundstart = function() {\n                invokeCallbacks(callbacks.soundstart);\n            };\n\n            recognition.onerror = function(event) {\n                invokeCallbacks(callbacks.error, event);\n                switch (event.error) {\n                    case \"network\":\n                        invokeCallbacks(callbacks.errorNetwork, event);\n                        break;\n                    case \"not-allowed\":\n                    case \"service-not-allowed\":\n                        // if permission to use the mic is denied, turn off auto-restart\n                        autoRestart = false;\n                        // determine if permission was denied by user or automatically.\n                        if (new Date().getTime() - lastStartedAt < 200) {\n                            invokeCallbacks(callbacks.errorPermissionBlocked, event);\n                        } else {\n                            invokeCallbacks(callbacks.errorPermissionDenied, event);\n                        }\n                        break;\n                }\n            };\n\n            recognition.onend = function() {\n                isListening = false;\n                invokeCallbacks(callbacks.end);\n                // annyang will auto restart if it is closed automatically and not by user action.\n                if (autoRestart) {\n                    // play nicely with the browser, and never restart annyang automatically more than once per second\n                    var timeSinceLastStart = new Date().getTime() - lastStartedAt;\n                    autoRestartCount += 1;\n                    if (autoRestartCount % 10 === 0) {\n                        if (debugState) {\n                            logMessage(\"Speech Recognition is repeatedly stopping and starting. See http://is.gd/annyang_restarts for tips.\");\n                        }\n                    }\n                    if (timeSinceLastStart < 1000) {\n                        setTimeout(function() {\n                            annyang.start({ paused: pauseListening });\n                        }, 1000 - timeSinceLastStart);\n                    } else {\n                        annyang.start({ paused: pauseListening });\n                    }\n                }\n            };\n\n            recognition.onresult = function(event) {\n                if (pauseListening) {\n                    if (debugState) {\n                        logMessage(\"Speech heard, but annyang is paused\");\n                    }\n                    return false;\n                }\n\n                // Map the results to an array\n                var SpeechRecognitionResult = event.results[event.resultIndex];\n                var results = [];\n                for (let k = 0; k < SpeechRecognitionResult.length; k++) {\n                    results[k] = SpeechRecognitionResult[k].transcript;\n                }\n\n                parseResults(results);\n            };\n\n            // build commands list\n            if (resetCommands) {\n                commandsList = [];\n            }\n            if (commands.length) {\n                this.addCommands(commands);\n            }\n        },\n\n        /**\n         * Start listening.\n         * It's a good idea to call this after adding some commands first, but not mandatory.\n         *\n         * Receives an optional options object which supports the following options:\n         *\n         * - `autoRestart`  (boolean) Should annyang restart itself if it is closed indirectly, because of silence or window conflicts?\n         * - `continuous`   (boolean) Allow forcing continuous mode on or off. Annyang is pretty smart about this, so only set this if you know what you're doing.\n         * - `paused`       (boolean) Start annyang in paused mode.\n         *\n         * #### Examples:\n         * ````javascript\n         * // Start listening, don't restart automatically\n         * annyang.start({ autoRestart: false });\n         * // Start listening, don't restart automatically, stop recognition after first phrase recognized\n         * annyang.start({ autoRestart: false, continuous: false });\n         * ````\n         * @param {Object} [options] - Optional options.\n         * @method start\n         */\n        start: function(options) {\n            initIfNeeded();\n            options = options || {};\n            if (options.paused !== undefined) {\n                pauseListening = !!options.paused;\n            } else {\n                pauseListening = false;\n            }\n            if (options.autoRestart !== undefined) {\n                autoRestart = !!options.autoRestart;\n            } else {\n                autoRestart = true;\n            }\n            if (options.continuous !== undefined) {\n                recognition.continuous = !!options.continuous;\n            }\n\n            lastStartedAt = new Date().getTime();\n            try {\n                recognition.start();\n            } catch (e) {\n                if (debugState) {\n                    logMessage(e.message);\n                }\n            }\n        },\n\n        /**\n         * Stop listening, and turn off mic.\n         *\n         * Alternatively, to only temporarily pause annyang responding to commands without stopping the SpeechRecognition engine or closing the mic, use pause() instead.\n         * @see [pause()](#pause)\n         *\n         * @method abort\n         */\n        abort: function() {\n            autoRestart = false;\n            autoRestartCount = 0;\n            if (isInitialized()) {\n                recognition.abort();\n            }\n        },\n\n        /**\n         * Pause listening. annyang will stop responding to commands (until the resume or start methods are called), without turning off the browser's SpeechRecognition engine or the mic.\n         *\n         * Alternatively, to stop the SpeechRecognition engine and close the mic, use abort() instead.\n         * @see [abort()](#abort)\n         *\n         * @method pause\n         */\n        pause: function() {\n            pauseListening = true;\n        },\n\n        /**\n         * Resumes listening and restore command callback execution when a result matches.\n         * If SpeechRecognition was aborted (stopped), start it.\n         *\n         * @method resume\n         */\n        resume: function() {\n            annyang.start();\n        },\n\n        /**\n         * Turn on the output of debug messages to the console. Ugly, but super-handy!\n         *\n         * @param {boolean} [newState=true] - Turn on/off debug messages\n         * @method debug\n         */\n        debug: function(newState = true) {\n            debugState = !!newState;\n        },\n\n        /**\n         * Set the language the user will speak in. If this method is not called, defaults to 'en-US'.\n         *\n         * @param {String} language - The language (locale)\n         * @method setLanguage\n         * @see [Languages](https://github.com/TalAter/annyang/blob/master/docs/FAQ.md#what-languages-are-supported)\n         */\n        setLanguage: function(language) {\n            initIfNeeded();\n            recognition.lang = language;\n        },\n\n        /**\n         * Add commands that annyang will respond to. Similar in syntax to init(), but doesn't remove existing commands.\n         *\n         * #### Examples:\n         * ````javascript\n         * var commands = {'hello :name': helloFunction, 'howdy': helloFunction};\n         * var commands2 = {'hi': helloFunction};\n         *\n         * annyang.addCommands(commands);\n         * annyang.addCommands(commands2);\n         * // annyang will now listen to all three commands\n         * ````\n         *\n         * @param {Object} commands - Commands that annyang should listen to\n         * @method addCommands\n         * @see [Commands Object](#commands-object)\n         */\n        addCommands: function(commands) {\n            var cb;\n\n            initIfNeeded();\n\n            for (let phrase in commands) {\n                if (commands.hasOwnProperty(phrase)) {\n                    cb = root[commands[phrase]] || commands[phrase];\n                    if (typeof cb === \"function\") {\n                        // convert command to regex then register the command\n                        registerCommand(commandToRegExp(phrase), cb, phrase);\n                    } else if (typeof cb === \"object\" && cb.regexp instanceof RegExp) {\n                        // register the command\n                        registerCommand(new RegExp(cb.regexp.source, \"i\"), cb.callback, phrase);\n                    } else {\n                        if (debugState) {\n                            logMessage(\"Can not register command: %c\" + phrase, debugStyle);\n                        }\n                        continue;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Remove existing commands. Called with a single phrase, an array of phrases, or methodically. Pass no params to remove all commands.\n         *\n         * #### Examples:\n         * ````javascript\n         * var commands = {'hello': helloFunction, 'howdy': helloFunction, 'hi': helloFunction};\n         *\n         * // Remove all existing commands\n         * annyang.removeCommands();\n         *\n         * // Add some commands\n         * annyang.addCommands(commands);\n         *\n         * // Don't respond to hello\n         * annyang.removeCommands('hello');\n         *\n         * // Don't respond to howdy or hi\n         * annyang.removeCommands(['howdy', 'hi']);\n         * ````\n         * @param {String|Array|Undefined} [commandsToRemove] - Commands to remove\n         * @method removeCommands\n         */\n        removeCommands: function(commandsToRemove) {\n            if (commandsToRemove === undefined) {\n                commandsList = [];\n            } else {\n                commandsToRemove = Array.isArray(commandsToRemove) ? commandsToRemove : [commandsToRemove];\n                commandsList = commandsList.filter(command => {\n                    for (let i = 0; i < commandsToRemove.length; i++) {\n                        if (commandsToRemove[i] === command.originalPhrase) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            }\n        },\n\n        /**\n         * Add a callback function to be called in case one of the following events happens:\n         *\n         * * `start` - Fired as soon as the browser's Speech Recognition engine starts listening.\n         *\n         * * `soundstart` - Fired as soon as any sound (possibly speech) has been detected.\n         *\n         *     This will fire once per Speech Recognition starting. See https://is.gd/annyang_sound_start.\n         *\n         * * `error` - Fired when the browser's Speech Recognition engine returns an error, this generic error callback will be followed by more accurate error callbacks (both will fire if both are defined).\n         *\n         *     The Callback function will be called with the error event as the first argument.\n         *\n         * * `errorNetwork` - Fired when Speech Recognition fails because of a network error.\n         *\n         *     The Callback function will be called with the error event as the first argument.\n         *\n         * * `errorPermissionBlocked` - Fired when the browser blocks the permission request to use Speech Recognition.\n         *\n         *     The Callback function will be called with the error event as the first argument.\n         *\n         * * `errorPermissionDenied` - Fired when the user blocks the permission request to use Speech Recognition.\n         *\n         *     The Callback function will be called with the error event as the first argument.\n         *\n         * * `end` - Fired when the browser's Speech Recognition engine stops.\n         *\n         * * `result` - Fired as soon as some speech was identified. This generic callback will be followed by either the `resultMatch` or `resultNoMatch` callbacks.\n         *\n         *     The Callback functions for this event will be called with an array of possible phrases the user said as the first argument.\n         *\n         * * `resultMatch` - Fired when annyang was able to match between what the user said and a registered command.\n         *\n         *     The Callback functions for this event will be called with three arguments in the following order:\n         *\n         *     * The phrase the user said that matched a command.\n         *     * The command that was matched.\n         *     * An array of possible alternative phrases the user might have said.\n         *\n         * * `resultNoMatch` - Fired when what the user said didn't match any of the registered commands.\n         *\n         *     Callback functions for this event will be called with an array of possible phrases the user might have said as the first argument.\n         *\n         * #### Examples:\n         * ````javascript\n         * annyang.addCallback('error', function() {\n         *   $('.myErrorText').text('There was an error!');\n         * });\n         *\n         * annyang.addCallback('resultMatch', function(userSaid, commandText, phrases) {\n         *   console.log(userSaid); // sample output: 'hello'\n         *   console.log(commandText); // sample output: 'hello (there)'\n         *   console.log(phrases); // sample output: ['hello', 'halo', 'yellow', 'polo', 'hello kitty']\n         * });\n         *\n         * // pass local context to a global function called notConnected\n         * annyang.addCallback('errorNetwork', notConnected, this);\n         * ````\n         * @param {String} type - Name of event that will trigger this callback\n         * @param {Function} callback - The function to call when event is triggered\n         * @param {Object} [context] - Optional context for the callback function\n         * @method addCallback\n         */\n        addCallback: function(type, callback, context) {\n            var cb = root[callback] || callback;\n            if (typeof cb === \"function\" && callbacks[type] !== undefined) {\n                callbacks[type].push({ callback: cb, context: context || this });\n            }\n        },\n\n        /**\n         * Remove callbacks from events.\n         *\n         * - Pass an event name and a callback command to remove that callback command from that event type.\n         * - Pass just an event name to remove all callback commands from that event type.\n         * - Pass undefined as event name and a callback command to remove that callback command from all event types.\n         * - Pass no params to remove all callback commands from all event types.\n         *\n         * #### Examples:\n         * ````javascript\n         * annyang.addCallback('start', myFunction1);\n         * annyang.addCallback('start', myFunction2);\n         * annyang.addCallback('end', myFunction1);\n         * annyang.addCallback('end', myFunction2);\n         *\n         * // Remove all callbacks from all events:\n         * annyang.removeCallback();\n         *\n         * // Remove all callbacks attached to end event:\n         * annyang.removeCallback('end');\n         *\n         * // Remove myFunction2 from being called on start:\n         * annyang.removeCallback('start', myFunction2);\n         *\n         * // Remove myFunction1 from being called on all events:\n         * annyang.removeCallback(undefined, myFunction1);\n         * ````\n         *\n         * @param type Name of event type to remove callback from\n         * @param callback The callback function to remove\n         * @returns undefined\n         * @method removeCallback\n         */\n        removeCallback: function(type, callback) {\n            var compareWithCallbackParameter = function(cb) {\n                return cb.callback !== callback;\n            };\n            // Go over each callback type in callbacks store object\n            for (let callbackType in callbacks) {\n                if (callbacks.hasOwnProperty(callbackType)) {\n                    // if this is the type user asked to delete, or he asked to delete all, go ahead.\n                    if (type === undefined || type === callbackType) {\n                        // If user asked to delete all callbacks in this type or all types\n                        if (callback === undefined) {\n                            callbacks[callbackType] = [];\n                        } else {\n                            // Remove all matching callbacks\n                            callbacks[callbackType] = callbacks[callbackType].filter(compareWithCallbackParameter);\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n         * Returns true if speech recognition is currently on.\n         * Returns false if speech recognition is off or annyang is paused.\n         *\n         * @return boolean true = SpeechRecognition is on and annyang is listening\n         * @method isListening\n         */\n        isListening: function() {\n            return isListening && !pauseListening;\n        },\n\n        /**\n         * Returns the instance of the browser's SpeechRecognition object used by annyang.\n         * Useful in case you want direct access to the browser's Speech Recognition engine.\n         *\n         * @returns SpeechRecognition The browser's Speech Recognizer currently used by annyang\n         * @method getSpeechRecognizer\n         */\n        getSpeechRecognizer: function() {\n            return recognition;\n        },\n\n        /**\n         * Simulate speech being recognized. This will trigger the same events and behavior as when the Speech Recognition\n         * detects speech.\n         *\n         * Can accept either a string containing a single sentence or an array containing multiple sentences to be checked\n         * in order until one of them matches a command (similar to the way Speech Recognition Alternatives are parsed)\n         *\n         * #### Examples:\n         * ````javascript\n         * annyang.trigger('Time for some thrilling heroics');\n         * annyang.trigger(\n         *     ['Time for some thrilling heroics', 'Time for some thrilling aerobics']\n         *   );\n         * ````\n         *\n         * @param string|array sentences A sentence as a string or an array of strings of possible sentences\n         * @returns undefined\n         * @method trigger\n         */\n        trigger: function(sentences) {\n            if (!annyang.isListening()) {\n                if (debugState) {\n                    if (!isListening) {\n                        logMessage(\"Cannot trigger while annyang is aborted\");\n                    } else {\n                        logMessage(\"Speech heard, but annyang is paused\");\n                    }\n                }\n                return;\n            }\n\n            if (!Array.isArray(sentences)) {\n                sentences = [sentences];\n            }\n\n            parseResults(sentences);\n        }\n    };\n\n    return annyang;\n});\n\n/**\n   * # Good to Know\n   *\n   * ## Commands Object\n   *\n   * Both the [init()]() and addCommands() methods receive a `commands` object.\n   *\n   * annyang understands commands with `named variables`, `splats`, and `optional words`.\n   *\n   * * Use `named variables` for one-word arguments in your command.\n   * * Use `splats` to capture multi-word text at the end of your command (greedy).\n   * * Use `optional words` or phrases to define a part of the command as optional.\n   *\n   * #### Examples:\n   * ````html\n   * <script>\n   * var commands = {\n   *   // annyang will capture anything after a splat (*) and pass it to the function.\n   *   // e.g. saying \"Show me Batman and Robin\" will call showFlickr('Batman and Robin');\n   *   'show me *tag': showFlickr,\n   *\n   *   // A named variable is a one-word variable, that can fit anywhere in your command.\n   *   // e.g. saying \"calculate October stats\" will call calculateStats('October');\n   *   'calculate :month stats': calculateStats,\n   *\n   *   // By defining a part of the following command as optional, annyang will respond\n   *   // to both: \"say hello to my little friend\" as well as \"say hello friend\"\n   *   'say hello (to my little) friend': greeting\n   * };\n   *\n   * var showFlickr = function(tag) {\n   *   var url = 'http://api.flickr.com/services/rest/?tags='+tag;\n   *   $.getJSON(url);\n   * }\n   *\n   * var calculateStats = function(month) {\n   *   $('#stats').text('Statistics for '+month);\n   * }\n   *\n   * var greeting = function() {\n   *   $('#greeting').text('Hello!');\n   * }\n   * </script>\n   * ````\n   *\n   * ### Using Regular Expressions in commands\n   * For advanced commands, you can pass a regular expression object, instead of\n   * a simple string command.\n   *\n   * This is done by passing an object containing two properties: `regexp`, and\n   * `callback` instead of the function.\n   *\n   * #### Examples:\n   * ````javascript\n   * var calculateFunction = function(month) { console.log(month); }\n   * var commands = {\n   *   // This example will accept any word as the \"month\"\n   *   'calculate :month stats': calculateFunction,\n   *   // This example will only accept months which are at the start of a quarter\n   *   'calculate :quarter stats': {'regexp': /^calculate (January|April|July|October) stats$/, 'callback': calculateFunction}\n   * }\n   ````\n   *\n   */\n","import EventEmitter from \"events\";\r\nimport shajs from \"sha.js\";\r\n\r\nclass OBSwebsocket extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n\r\n        this.messageId = 0;\r\n        this.address = \"\";\r\n        this.password = \"\";\r\n    }\r\n\r\n    connect(address, password) {\r\n        this.address = address;\r\n        this.password = password;\r\n\r\n        this.ws = new WebSocket(`ws://${address}`);\r\n\r\n        this.ws.onopen = this.onOpen.bind(this);\r\n        this.ws.onmessage = this.onMessage.bind(this);\r\n        this.ws.onerror = this.onError.bind(this);\r\n        this.ws.onclose = this.onClose.bind(this);\r\n    }\r\n\r\n    async onOpen() {\r\n        if (this.ws !== null && this.ws.readyState === 1) {\r\n            console.log(\"Successfully Connected to OBS\");\r\n\r\n            const res = await this.send({ \"request-type\": \"GetAuthRequired\" });\r\n\r\n            if (res.authRequired) {\r\n                this.authenticate(res);\r\n            } else {\r\n                this.emit(\"connected\");\r\n            }\r\n        }\r\n    }\r\n\r\n    onClose(e) {\r\n        this.emit(\"error\", e);\r\n    }\r\n\r\n    close() {\r\n        if (this.ws) {\r\n            this.ws.close();\r\n        }\r\n    }\r\n\r\n    onError(e) {\r\n        this.emit(\"error\", e);\r\n    }\r\n\r\n    onMessage(message) {\r\n        const data = JSON.parse(message.data);\r\n\r\n        console.log(\"onmessageeee\", data);\r\n\r\n        if (data[\"message-id\"]) {\r\n            this.emit(`messageId-${data[\"message-id\"]}`, data);\r\n        } else {\r\n            this.emit(data[\"update-type\"], data);\r\n        }\r\n    }\r\n\r\n    send(message) {\r\n        return new Promise((resolve, reject) => {\r\n            const id = this.generateMessageId();\r\n            message[\"message-id\"] = id;\r\n\r\n            this.once(`messageId-${id}`, data => {\r\n                if (data.status === \"error\") {\r\n                    reject(data);\r\n                }\r\n\r\n                resolve(data);\r\n            });\r\n\r\n            this.ws.send(JSON.stringify(message));\r\n        });\r\n    }\r\n\r\n    generateMessageId() {\r\n        return String(this.messageId++);\r\n    }\r\n\r\n    async authenticate({ salt, challenge }) {\r\n        const passwordSaltHash = new shajs.sha256().update(this.password + salt).digest(\"base64\");\r\n        const authResponse = new shajs.sha256().update(passwordSaltHash + challenge).digest(\"base64\");\r\n\r\n        try {\r\n            await this.send({ \"request-type\": \"Authenticate\", auth: authResponse });\r\n            this.emit(\"connected\");\r\n        } catch (error) {\r\n            this.emit(\"authfail\");\r\n        }\r\n    }\r\n}\r\n\r\nexport default OBSwebsocket;\r\n","import React, { Component } from \"react\";\r\n\r\nclass Login extends Component {\r\n    state = {\r\n        host: \"localhost\",\r\n        port: \"4444\",\r\n        password: \"\"\r\n    };\r\n\r\n    handleChange = e => {\r\n        this.setState({ [e.target.name]: e.target.value });\r\n    };\r\n\r\n    handleSubmit = e => {\r\n        this.props.client.connect(`${this.state.host}:${this.state.port}`, this.state.password);\r\n\r\n        e.preventDefault();\r\n    };\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                {this.props.error && <p>{this.props.error}</p>}\r\n                {this.props.authFail && <p>Failed to authenticate</p>}\r\n\r\n                <form onSubmit={this.handleSubmit}>\r\n                    <label>\r\n                        Host:\r\n                        <input name=\"host\" type=\"text\" value={this.state.host} onChange={this.handleChange} />\r\n                    </label>\r\n                    <label>\r\n                        Port:\r\n                        <input name=\"port\" type=\"text\" value={this.state.port} onChange={this.handleChange} />\r\n                    </label>\r\n                    <label>\r\n                        Password:\r\n                        <input name=\"password\" type=\"text\" value={this.state.password} onChange={this.handleChange} />\r\n                    </label>\r\n                    <input type=\"submit\" value=\"Submit\" />\r\n                </form>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Login;\r\n","import React, { Component } from \"react\";\r\nimport annyang from \"./annyang.min\";\r\n\r\nclass Dashboard extends Component {\r\n    state = {\r\n        trigger: \"obs\",\r\n        commands: []\r\n    };\r\n\r\n    componentDidMount() {\r\n        if (annyang) {\r\n            // Let's define a command.\r\n            const commands = {\r\n                hello: () => {\r\n                    alert(\"Hello world!\");\r\n                },\r\n\r\n                [this.state.trigger + \" switch (to) :scene\"]: async scene => {\r\n                    try {\r\n                        const res = await this.props.client.send({ \"request-type\": \"SetCurrentScene\", \"scene-name\": scene });\r\n                        console.log(\"res\", res);\r\n                        console.log(\"switched scene to\", scene);\r\n                        res.scene = scene;\r\n\r\n                        this.setState(prevState => {\r\n                            return {\r\n                                commands: [...prevState.commands, res]\r\n                            };\r\n                        });\r\n                    } catch (error) {\r\n                        error.scene = scene;\r\n\r\n                        this.setState(prevState => {\r\n                            return {\r\n                                commands: [...prevState.commands, error]\r\n                            };\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n\r\n            // Add our commands to annyang\r\n            annyang.addCommands(commands);\r\n            annyang.debug(true);\r\n\r\n            // annyang.addCallback(\"resultMatch\", (userSaid, commandText, phrases) => {\r\n            //     this.setState(prevState => {\r\n            //         return {\r\n            //             commands: [...prevState.commands, userSaid]\r\n            //         };\r\n            //     });\r\n            // });\r\n\r\n            // Start listening.\r\n            annyang.start();\r\n        }\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        // would filter() be better?\r\n        if (this.state.commands.length === 10) {\r\n            this.setState(prevState => {\r\n                return {\r\n                    commands: prevState.commands.slice(1)\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"Dashboard\">\r\n                <p>Voice control</p>\r\n                {this.state.text && <h2>{this.state.text}</h2>}\r\n\r\n                {this.state.commands.map(msg => (\r\n                    <p key={msg[\"message-id\"]}>{JSON.stringify(msg)}</p>\r\n                ))}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Dashboard;\r\n","import React, { Component } from \"react\";\nimport Client from \"./components/obs\";\n\nimport Login from \"./components/login\";\nimport Dashboard from \"./components/dashboard\";\n\nclass App extends Component {\n    state = {\n        client: new Client(),\n        connected: false,\n        authFail: false,\n        error: null\n    };\n\n    async componentDidMount() {\n        this.state.client.on(\"connected\", () => {\n            this.setState({ connected: true, authFail: false, error: null });\n        });\n\n        this.state.client.on(\"authfail\", () => {\n            this.setState({ connected: false, authFail: true, error: \"\" });\n        });\n\n        this.state.client.on(\"error\", error => {\n            if (error.code === 1006) {\n                this.setState({ error: \"Can't connect to websocket\", connected: false });\n                return;\n            }\n\n            console.log(error);\n        });\n    }\n\n    render() {\n        return !this.state.connected ? <Login {...this.state} /> : <Dashboard {...this.state} />;\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}